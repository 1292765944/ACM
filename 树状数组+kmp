#include<stdio.h>
#include<string.h>
#include<algorithm>
using namespace std;
#define N 1000010
int a[N],b[N],d[N];
int c[N];                //树状数组中的元素
int m1[N];  //（匹配串中）m1表示小于，m2表示小于等于
int n,k,s;
int next[N];
int all;
int lowbit(int x){
  return x&(x^(x-1));
}
int sum(int x){
	int ss=0;
	while(x>0){
		ss+=c[x];
		x-=lowbit(x);
	}
	return ss;
}
void update(int x,int val){
	while(x<=s){
		c[x]+=val;
		x+=lowbit(x);
	}
}
void getnext(){
	int i=1,j=0,kk;
	next[1]=0;
	while(i<=k){
		if(j==0 || sum(b[i]-1)==m1[j]){
			i++,j++;
			next[i]=j;
			if(i==k+1) return ;
			update(b[i],1);
		}
		else{
            for(kk=i-j+1;kk<=i-next[j];kk++)        //这里对next[j]之前的b[i]都要消除
				update(b[kk],-1);
			j=next[j];
        }
	}
}
int kmp(){                //这里对待匹配串用树状数组记录
	int i=1,j=1,f;
	update(a[1],1);
	all=0;
	while(i<=n){
		if(j==0 || sum(a[i]-1)==m1[j]){
			++i,++j;
			if(i<=n)
				update(a[i],1);
		}
		else{
			for(f=i-j+1;f<=i-next[j];f++)
				update(a[f],-1);
			j=next[j];
		}
		if(j>k){
			for(f=i-j+1;f<=i-next[j];f++)
				update(a[f],-1);
			all++;
			j=next[j];
		}
	}
	return all;
}
int main(){
	int i,j;
	freopen("a.txt","r",stdin);
	freopen("b.txt","w",stdout);
	while(scanf("%d %d",&k,&n)==2){
		for(i=1;i<=k;i++){
			scanf("%d",&b[i]);
		}
		for(i=1;i<=n;i++){
			scanf("%d",&a[i]);
			d[i]=a[i];
		}
	    	sort(d+1,d+1+n);
	    	s=unique(d+1,d+1+n)-d-1;
	    	for(i=1;i<=n;i++)
	        a[i]=lower_bound(d+1,d+1+s,a[i])-d;
		memset(c,0,sizeof(c));
		memset(m1,0,sizeof(m1));
		for(i=1;i<=k;i++){
			update(b[i],1);
			m1[i]=sum(b[i]-1);
		}
	
		memset(c,0,sizeof(c));
		getnext();
	
		memset(c,0,sizeof(c));
		printf("%d\n",kmp());
	}
}
