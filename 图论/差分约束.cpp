首先讨论这种标准形式的问题
X1 - X2 <= 0
X1 - X5 <= -1
X2 - X5 <= 1
X3 - X1 <= 5
X4 - X1 <= 4
X4 - X3 <= -1
X5 - X3 <= -3
X5 - X4 <= -3

上面的不等式组全都是两个未知数的差小于等于某个常数（大于等于也可以，左右乘以-1就可以化成小于等于）。这样的不等式组就称作差分约束系统。

解法利用到了单源最短路径问题中的三角形不等式。

即对于任何一条边u -> v，都有：d(v) <= d(u) + w(u, v)，其中d(u)和d(v)是从源点分别到点u和点v的最短路径的权值，w(u, v)是边u -> v的权值。

显然以上不等式就是d(v) - d(u) <= w(u, v)。这个形式正好和差分约束系统中的不等式形式相同。于是我们就可以把一个差分约束系统转化成一张图，每个未知数Xi对应图中的一个顶点Vi，把所有不等式都化成图中的一条边。对于不等式Xi - Xj <= c，把它化成三角形不等式：Xi <= Xj + c，就可以化成边Vj -> Vi，权值为c。最后，我们在这张图上求一次单源最短路径，这些三角形不等式就会全部都满足了，因为它是最短路径问题的基本性质嘛。

实际求解过程中，我们初始化所有的d数组为0，然后根据连边情况跑spfa即可，最后得到的d数组就是最小值。当然如果出现负环，那表示某几个不等式互相矛盾。

比如UVA 11478

[cpp] view plaincopy

    bool spfa(int mid){  
        queue<int>q;  
        int i,j;  
        for(i=1;i<=n;i++){  
            dis[i]=0;   //这里初始化为0只去搜负环  
            vis[i]=1;  
            tim[i]=1;  
            q.push(i);  
        }  
        while(!q.empty()){  
            int u=q.front();  
            q.pop();  
            vis[u]=0;  
            for(i=head[u];i!=-1;i=edge[i].next){  
                int v=edge[i].v;  
                if(dis[v]>dis[u]+edge[i].w-mid){  
                    dis[v]=dis[u]-mid+edge[i].w;  
                    if(!vis[v]){  
                        vis[v]=1;  
                        q.push(v);  
                        if(++tim[v]>n) return 0;  
                    }  
                }  
            }  
        }  
        return 1;  
    }  


当然还有对称的一种情况，就是不等式组都是>=方向，这个相当与最长路径的定义，d(v) >= d(u) + w(u, v).

实际求解过程中，我们依然初始化所有的d数组为0，然后根据连边情况跑spfa即可，最后得到的d数组就是最大值。如果出现正环同理表明出现矛盾


总结下来就是这么个结论：

如果是求最值

求最大值，把不等式全变为<=,做最短路；
求最小值，把不等式全变为>=,做最长路。
如果只是判断是否有解，则可统一为建好图用spfa判负环即可
